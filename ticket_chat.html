<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Ticket Chat | Game Store</title>

  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet"/>
  <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet"/>
  <link rel="stylesheet" href="landing.css" />

  <style>
    body { background: #0b0b0b; color: #eee; font-family: 'Poppins', sans-serif; }
    main {
      max-width: 800px;
      margin: 80px auto;
      background: #1a1a1a;
      border: 1px solid #262626;
      border-radius: 14px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0,0,0,.3);
    }
    h2 {
      text-align: center;
      margin-bottom: 20px;
      color: #fff;
    }
    .chat-box {
      background: #111;
      border-radius: 10px;
      padding: 15px;
      height: 400px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 15px;
    }
    .msg {
      max-width: 80%;
      padding: 10px 14px;
      border-radius: 14px;
      font-size: .95rem;
      line-height: 1.4;
    }
    .user {
      align-self: flex-end;
      background: #ff4757;
      color: #fff;
      border-bottom-right-radius: 2px;
    }
    .admin {
      align-self: flex-start;
      background: #2ed573;
      color: #000;
      border-bottom-left-radius: 2px;
    }
    .msg-time {
      font-size: .75rem;
      opacity: .7;
      margin-top: 2px;
    }
    .send-box {
      display: flex;
      gap: 10px;
    }
    .send-box input {
      flex: 1;
      background: #222;
      border: 1px solid #333;
      color: #fff;
      padding: 10px;
      border-radius: 8px;
      outline: none;
    }
    .send-box button {
      background: #ff4757;
      border: none;
      color: #fff;
      padding: 10px 18px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
    }
    .send-box button:hover { filter: brightness(1.1); }
    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #aaa;
      margin-bottom: 15px;
      text-decoration: none;
    }
    .back-link:hover { color: #fff; }
  </style>
</head>
<body>
    <a href="mytickets.html" class="back-link">
  <i class='bx bx-arrow-back'></i> Back to My Tickets
</a>


  

  <main>
    <h2 id="ticketTitle">Ticket Chat</h2>
    <div class="chat-box" id="chatBox">
      <div>Loading chat...</div>
    </div>
    <div class="send-box">
      <input type="text" id="msgInput" placeholder="Type your message..." />
      <button id="sendBtn"><i class='bx bx-send'></i></button>
    </div>
  </main>

  <!-- Firebase Logic -->
  <!-- Firebase Logic (robust replacement) -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getFirestore, doc, collection, addDoc, onSnapshot, query, orderBy,
    getDocs, getDoc, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCnIL_Lg-sEQs-52YRUL9PTaWTWc4Xu5xA",
    authDomain: "final-year-b1cc2.firebaseapp.com",
    projectId: "final-year-b1cc2",
    storageBucket: "final-year-b1cc2.firebasestorage.app",
    messagingSenderId: "537245015385",
    appId: "1:537245015385:web:ab79c9ec5e2a74cc924048",
    measurementId: "G-V6SWSF6F2D"
  };

  // initialize (if already initialized elsewhere this is harmless in module builds)
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  const params = new URLSearchParams(window.location.search);
  const ticketId = params.get("id");

  const chatBox = document.getElementById("chatBox");
  const msgInput = document.getElementById("msgInput");
  const sendBtn = document.getElementById("sendBtn");
  const titleEl = document.getElementById("ticketTitle");

  let unsub = null; // to detach snapshot listener

  function renderEmpty() {
    chatBox.innerHTML = '<div class="msg-time" style="opacity:.9;text-align:center">No messages yet. Send the first message.</div>';
  }

  function renderDocToElement(data){
    const text = data.text ?? data.message ?? data.msg ?? "";
    const sender = (data.sender ?? data.from ?? "").toString().toLowerCase();
    const tsField = data.timestamp ?? data.createdAt ?? data.time ?? null;

    const div = document.createElement("div");
    div.className = `msg ${sender === "admin" || sender === "support" ? "admin" : "user"}`;
    const timeStr = tsField?.toDate ? new Date(tsField.toDate()).toLocaleString()
                  : (tsField ? new Date(tsField).toLocaleString() : "");
    div.innerHTML = `${escapeHtml(text)}<div class="msg-time">${escapeHtml(timeStr)}</div>`;
    return div;
  }

  function escapeHtml(s=""){ return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;"); }

  // render from a QuerySnapshot docs array
  function renderFromDocs(docs){
    chatBox.innerHTML = "";
    if (!docs || docs.length === 0) { renderEmpty(); return; }
    docs.forEach(d => {
      const el = renderDocToElement(d.data());
      chatBox.appendChild(el);
    });
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  // fallback rendering when we do a one-time getDocs and need to manually sort
  function renderFromPlainDocsArray(plainDocs){
    // create array with timestamps (try multiple fields)
    const arr = plainDocs.map(d => {
      const data = d.data();
      let t = null;
      if (data.timestamp?.toDate) t = data.timestamp.toDate().getTime();
      else if (data.createdAt?.toDate) t = data.createdAt.toDate().getTime();
      else if (data.timestamp) t = new Date(data.timestamp).getTime();
      else if (data.createdAt) t = new Date(data.createdAt).getTime();
      else t = 0;
      return { doc: d, t };
    }).sort((a,b)=> a.t - b.t).map(x => x.doc);
    renderFromDocs(arr);
  }

  async function attachMessagesListener(ticketId){

    if (typeof unsub === "function") { unsub(); unsub = null; }

    const msgsRef = collection(db, "tickets", ticketId, "messages");

    try {
      const q = query(msgsRef, orderBy("timestamp", "asc"));
      unsub = onSnapshot(q, snap => {
        renderFromDocs(snap.docs);
      }, async (err) => {
        console.warn("Realtime 'timestamp' ordering failed, trying 'createdAt' ordering:", err);
        try {
          const q2 = query(msgsRef, orderBy("createdAt", "asc"));
          if (typeof unsub === "function") { unsub(); unsub = null; }
          unsub = onSnapshot(q2, snap2 => {
            renderFromDocs(snap2.docs);
          }, async (err2) => {
            console.warn("Realtime 'createdAt' ordering failed:", err2, "Falling back to getDocs.");
            // final fallback: one-time getDocs and client-side sorting
            try {
              const snap3 = await getDocs(msgsRef);
              renderFromPlainDocsArray(snap3.docs);
            } catch (e) {
              console.error("Failed final getDocs fallback for messages:", e);
              chatBox.innerHTML = "<div>Failed to load messages.</div>";
            }
          });
        } catch (e) {
          console.error("Error in createdAt fallback setup:", e);
          // fallback getDocs
          try {
            const snap4 = await getDocs(msgsRef);
            renderFromPlainDocsArray(snap4.docs);
          } catch (e2) {
            console.error("Final fallback getDocs failed:", e2);
            chatBox.innerHTML = "<div>Failed to load messages.</div>";
          }
        }
      });
    } catch (e) {
      console.warn("Error attaching timestamp listener; using fallback getDocs:", e);
      try {
        const snap = await getDocs(msgsRef);
        renderFromPlainDocsArray(snap.docs);
      } catch (err) {
        console.error("Fallback getDocs failed:", err);
        chatBox.innerHTML = "<div>Failed to load messages.</div>";
      }
    }
  }

  // main auth/ticket flow
  onAuthStateChanged(auth, async (user) => {
    if (!ticketId){
      chatBox.innerHTML = "<div>No ticket selected.</div>";
      sendBtn.disabled = true;
      return;
    }

    if (!user){
      chatBox.innerHTML = "<div>Please log in to view this chat.</div>";
      sendBtn.disabled = true;
      return;
    }

    sendBtn.disabled = false;

    // load ticket metadata (title)
    try {
      const ticketRef = doc(db, "tickets", ticketId);
      const ticketSnap = await getDoc(ticketRef);
      if (ticketSnap.exists()){
        const td = ticketSnap.data();
        titleEl.textContent = td.subject ? `Ticket â€” ${td.subject}` : "Ticket Chat";
      } else {
        titleEl.textContent = "Ticket Chat";
      }
    } catch (err) {
      console.error("Failed to load ticket doc:", err);
    }

    chatBox.innerHTML = "<div class='msg-time' style='opacity:.9;text-align:center'>Loading chat...</div>";

    // Attach realtime listener with fallbacks
    attachMessagesListener(ticketId);

    // Ensure we do not attach multiple click handlers
    sendBtn.replaceWith(sendBtn.cloneNode(true));
    const newSendBtn = document.getElementById("sendBtn");

    newSendBtn.addEventListener("click", async () => {
      const text = (msgInput.value || "").trim();
      if (!text) return;
      newSendBtn.disabled = true;
      try {
        const msgsRef = collection(db, "tickets", ticketId, "messages");
        await addDoc(msgsRef, {
          sender: "user",
          text,
          timestamp: serverTimestamp(),   // consistent timestamp field
          createdAt: serverTimestamp()    // also useful if you used createdAt elsewhere
        });
   
        msgInput.value = "";
      } catch (err) {
        console.error("Error sending message:", err);
        alert("Failed to send message.");
      } finally {
        newSendBtn.disabled = false;
      }
    });

    // also send on Enter
    msgInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey){
        e.preventDefault();
        document.getElementById("sendBtn").click();
      }
    });
  });

  // cleanup on unload
  window.addEventListener("beforeunload", () => {
    if (typeof unsub === "function") unsub();
  });
</script>


</body>
</html>
